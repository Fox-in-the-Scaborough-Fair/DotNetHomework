<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin-when-crossorigin" />
    <meta name="description" content="guavacache源码阅读笔记 官方文档： https://github.com/google/guava/wiki/CachesExplained 中文版： https://www.jianshu" />
    <meta property="og:description" content="guavacache源码阅读笔记 官方文档： https://github.com/google/guava/wiki/CachesExplained 中文版： https://www.jianshu" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>guavacache源码阅读笔记 - 张天赐的博客 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=6tvK5XC6GPbg3p_sy7wzz_2291HoYACr4440iKBzQIw" />
    
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/tc971121/custom.css?v=WiP/H2fd68Xw30RmQSvDNref2SA=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/custom/bundle-custom-mobile.min.css?v=OayYBbtUbH4FYkn_bTL4VVf4DsEOiTHSWhbl11KyY6Y" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/tc971121/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/tc971121/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/tc971121/wlwmanifest.xml" />
    <script>
        var currentBlogId = 322910;
        var currentBlogApp = 'tc971121';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'Custom';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2021-06-18 05:29';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=l5MLSTLemATH1_zJmhkn0AWeaJtyzREb_jcbx3aWNaQ"></script>
    
    
    
</head>
<body class="no-navbar">
    <a name="top"></a>
            <div id="bannerbar" class="bannerbar-mobile formobile">
            <a href="https://cloud.baidu.com/campaign/2021mid/index.html?track=cp:bokeyuan|pf:mb|pp:bokeyuan-huodong-21nianzhongdacu-neiyeyidongduantonglanbanner|pu:21nianzhongdacu-neiyeyidongduantonglanbanner|ci:21nzdc|kw:10224547" onclick="ga('send', 'event', 'Link', 'click', 'baidu-cpa-blog-bannerbar-mobile')">
                <img src="https://img2020.cnblogs.com/blog/35695/202106/35695-20210610184806729-1738888164.jpg" alt="" />
            </a>
            </div>
    <div id="top_nav" class="navbar forpc navbar-custom">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding"><a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a></li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="/images/aggsite/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=J0WS2P2iPgaIVgXxcAhliw4AFZIpaTWxtdoNAv9eiCA" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    
    <!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/tc971121/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/tc971121/">知其然知其所以然</a>
</h1>
<h2></h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/tc971121/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E5%BC%A0%E5%A4%A9%E8%B5%90%E7%9A%84%E5%8D%9A%E5%AE%A2">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/tc971121/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tc971121/p/14900517.html">
    <span>guavacache源码阅读笔记</span>
    



</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="guavacache源码阅读笔记">guavacache源码阅读笔记</h1>
<p>官方文档：</p>
<p><a href="https://github.com/google/guava/wiki/CachesExplained" target="_blank">https://github.com/google/guava/wiki/CachesExplained</a></p>
<p>中文版：</p>
<p><a href="https://www.jianshu.com/p/88ec858cc021?from=singlemessage" target="_blank">https://www.jianshu.com/p/88ec858cc021?from=singlemessage</a></p>
<p>参考文档：</p>
<p>美团技术团队：《缓存那些事儿》</p>
<p><a href="https://tech.meituan.com/2017/03/17/cache-about.html" target="_blank">https://tech.meituan.com/2017/03/17/cache-about.html</a></p>
<p>​	缓存在很多数情况下都非常有用，例如，如果计算一个值或者获取一个值时，代价十分昂贵的话，你就可以考虑使用缓存，并且针对某个特定的输入，你可能不止一次需要它的值。</p>
<p>​     缓存Cache和ConcurrentMap很相像，但又不完全一样。最根本的区别是，ConcurrentMap会保存所有添加到其中的元素直到它们被明确的移除。在另一方面，Cache通常可以配置一个自动化的回收策略去限制它的内存空间。在某些情况下，LoadingCache还是非常有用的，即使它不清除条目。</p>
<p>Guava Cache是Google开源的Java重用工具集库Guava里的一款缓存工具，其主要实现的缓存功能有：</p>
<ul>
<li>自动将entry节点加载进缓存结构中；</li>
<li>当缓存的数据超过设置的最大值时，使用LRU算法移除；</li>
<li>具备根据entry节点上次被访问或者写入时间计算它的过期机制；</li>
<li>缓存的key被封装在WeakReference引用内；</li>
<li>缓存的Value被封装在WeakReference或SoftReference引用内；</li>
<li>统计缓存使用过程中命中率、异常率、未命中率等统计数据。</li>
</ul>
<p>Guava Cache的架构设计灵感来源于ConcurrentHashMap，我们前面也提到过，简单场景下可以自行编码通过hashmap来做少量数据的缓存，但是，如果结果可能随时间改变或者是希望存储的数据空间可控的话，自己实现这种数据结构还是有必要的。</p>
<p>核心类图</p>
<p><img src="https://img2020.cnblogs.com/blog/1054413/202106/1054413-20210618172642593-1112308356.png" alt="" loading="lazy"></p>
<p>核心类及接口的说明，简单的理解如下：</p>
<ul>
<li>Cache接口是Guava对外暴露的缓存接口，提供以下动作：</li>
</ul>
<pre><code class="language-java">public interface Cache&lt;K, V&gt; {

  /**
   * 当key存在缓存中的时候返回value，否则返回null
   */
  @Nullable
  V getIfPresent(@CompatibleWith("K") Object key);

  /**
   * 如果key存在缓存中返回value，否则通过loader获取value
   * 如果已缓存返回，否则创建，缓存，返回。
   */
  V get(K key, Callable&lt;? extends V&gt; loader) throws ExecutionException;

  /**
   * 返回一个map，这个map包含所有存在缓存中的entries
   */
  ImmutableMap&lt;K, V&gt; getAllPresent(Iterable&lt;?&gt; keys);

  /**
   * 添加一个缓存entry
   * @since 11.0
   */
  void put(K key, V value);

  void putAll(Map&lt;? extends K, ? extends V&gt; m);

  /** 
   * 移除给定的key的缓存entry
   * */
  void invalidate(@CompatibleWith("K") Object key);

  /**
   * 移除给定的keys的缓存entries
   * @since 11.0
   */
  void invalidateAll(Iterable&lt;?&gt; keys);

  /** 
   * 移除所有的缓存
   * */
  void invalidateAll();

  /** 
   * 返回缓存个数
   * */
  @CheckReturnValue
  long size();

  /**
   * 统计
   */
  @CheckReturnValue
  CacheStats stats();

  /**
   * 返回所有缓存entries的一个视图，一个线程安全的map
   */
  @CheckReturnValue
  ConcurrentMap&lt;K, V&gt; asMap();

  /**
   * 根据实现策略，主动清除无效缓存
   */
  void cleanUp();
}
</code></pre>
<ul>
<li>
<p>LoadingCache接口继承自Cache接口，增加了<strong>获取不到缓存自动加载</strong>的特性。</p>
<p>通过CacheBuilder构造传入自动加载策略CacheLoader</p>
<pre><code class="language-java">LoadingCache&lt;String, String&gt; loadingCache = CacheBuilder.newBuilder()
        .build(
                new CacheLoader&lt;String, String&gt;() {
                    @Override
                    public String load(String key) throws Exception {
                        //创建加载缓存
                        return key;
                    }
                });
</code></pre>
</li>
</ul>
<pre><code class="language-java">public interface LoadingCache&lt;K, V&gt; extends Cache&lt;K, V&gt;, Function&lt;K, V&gt; {

  /**
   * 获取缓存，获取不到就 创建 缓存 返回
   * 显示声明异常ExecutionException 需要手动捕获处理 
   */
  V get(K key) throws ExecutionException;

  /**
   * 未检查的获取方法，加载缓存过程中可能抛出异常 
   * 获取缓存，获取不到就 创建 缓存 返回
   */
  V getUnchecked(K key);

  ImmutableMap&lt;K, V&gt; getAll(Iterable&lt;? extends K&gt; keys) throws ExecutionException;
  
  @Deprecated
  @Override
  V apply(K key);

  void refresh(K key);

  @Override
  ConcurrentMap&lt;K, V&gt; asMap();
}
</code></pre>
<ul>
<li>LocalManualCache是Cache接口的标准实现，顾名思义手动的获取缓存，当加载不到缓存需手动传入Callable&lt;? extends V&gt; loader 手动加载。在实现细节中，Callable接口也是被封装成匿名CacheLoader，负责加载key到缓存。</li>
</ul>
<pre><code class="language-java">@Override
public V get(K key, final Callable&lt;? extends V&gt; valueLoader) throws ExecutionException {
  checkNotNull(valueLoader);
  return localCache.get(
      key,
      new CacheLoader&lt;Object, V&gt;() {
        @Override
        public V load(Object key) throws Exception {
          return valueLoader.call();
        }
      });
}
</code></pre>
<ul>
<li>LocalLoadingCache实现LoadingCache接口并继承LocalManualCache，实现自动加载缓存特性。</li>
</ul>
<pre><code class="language-java">static class LocalLoadingCache&lt;K, V&gt; extends LocalManualCache&lt;K, V&gt;
    implements LoadingCache&lt;K, V&gt; {

  LocalLoadingCache(
      CacheBuilder&lt;? super K, ? super V&gt; builder, CacheLoader&lt;? super K, V&gt; loader) {
    super(new LocalCache&lt;K, V&gt;(builder, checkNotNull(loader)));
  }

  // LoadingCache methods

  @Override
  public V get(K key) throws ExecutionException {
    return localCache.getOrLoad(key);
  }

  @Override
  public V getUnchecked(K key) {
    try {
      return get(key);
    } catch (ExecutionException e) {
      throw new UncheckedExecutionException(e.getCause());
    }
  }

  @Override
  public ImmutableMap&lt;K, V&gt; getAll(Iterable&lt;? extends K&gt; keys) throws ExecutionException {
    return localCache.getAll(keys);
  }

  @Override
  public void refresh(K key) {
    localCache.refresh(key);
  }

  @Override
  public final V apply(K key) {
    return getUnchecked(key);
  }

  // Serialization Support

  private static final long serialVersionUID = 1;

  @Override
  Object writeReplace() {
    return new LoadingSerializationProxy&lt;&gt;(localCache);
  }
}
</code></pre>
<ul>
<li>
<p>LocalCache是核心存储层，是真正意义上数据存放的地方，继承了java.util.AbstractMap同时也实现了ConcurrentMap接口，实现方式参照了1.7版本的ConcurrentHashMap，使用多个segments方式的细粒度锁，在保证线程安全的同时，支持高并发场景需求。LocalCache类似于Map，它是存储键值对的集合，不同的是它还需要处理evict、expire、dynamic load等算法逻辑，需要一些额外信息来实现这些操作。如下图cache的内存数据模型，可以看到，使用ReferenceEntry接口来封装一个键值对，而用ValueReference来封装Value值，之所以用Reference命令，是因为Cache要支持WeakReference Key和SoftReference、WeakReference value。同时每一个segment中维护了writeQueue,accessQueue,keyReferenceQueue,valueReferenceQueue,recencyQueue队列来支持不同回收策略。</p>
<p>​        大致看一下LocalCache和Segment的成员变量和构造方法（LocalCache这个类实在是太庞大了，里面嵌入了大量的内部类 - -）</p>
</li>
<li>
<pre><code class="language-java">class LocalCache&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt; {
  // Constants 常量

  /**
   * 最大容量 1073741824
   */
  static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

  /** 
   * 最大允许的segment数
   * 65536 */
  static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative

  /**
   * 获取锁最大重试次数
  static final int CONTAINS_VALUE_RETRIES = 3;

  /**
   * 每个segment在访问操作结束会缓冲一定的次数后执行回收缓存操作
   * 驱除阀值
   * 它只在每次第 64 次调用postReadCleanup()时执行
   * 63
   */
  static final int DRAIN_THRESHOLD = 0x3F;

  /**
   * 每次驱除reference queues队列时 最大驱除个数
   */
  // TODO(fry): empirically optimize this
  static final int DRAIN_MAX = 16;

  // Fields 成员变量

  static final Logger logger = Logger.getLogger(LocalCache.class.getName());

  /**
   * Mask value for indexing into segments. The upper bits of a key's hash code are used to choose
   * the segment.
   */
  final int segmentMask;

  /**
   * Shift value for indexing within segments. Helps prevent entries that end up in the same segment
   * from also ending up in the same bucket.
   */
  final int segmentShift;

  /** The segments, each of which is a specialized hash table. */
  final Segment&lt;K, V&gt;[] segments;

  /** The concurrency level.
   * 最大并发数
   * */
  final int concurrencyLevel;

  /** Strategy for comparing keys.
   *
   * 比较keys的工具类
   * */
  final Equivalence&lt;Object&gt; keyEquivalence;

  /** Strategy for comparing values.
   * 比较值的工具类
   * */
  final Equivalence&lt;Object&gt; valueEquivalence;

  /** Strategy for referencing keys.
   *
   * key引用强度
   * */
  final Strength keyStrength;

  /** Strategy for referencing values.
   *
   * value引用强度
   * */
  final Strength valueStrength;

  /** The maximum weight of this map. UNSET_INT if there is no maximum.
   * 最大容纳大小
   * */
  final long maxWeight;

  /** Weigher to weigh cache entries.
   * 计算每个cache的权重 由用户自己实现
   * */
  final Weigher&lt;K, V&gt; weigher;

  /** How long after the last access to an entry the map will retain that entry.
   * 访问过期时间
   * */
  final long expireAfterAccessNanos;

  /** How long after the last write to an entry the map will retain that entry.
   * 写过期时间
   * */
  final long expireAfterWriteNanos;

  /** How long after the last write an entry becomes a candidate for refresh.
   * 刷新时间
   * */
  final long refreshNanos;

  /** Entries waiting to be consumed by the removal listener.
   *
   * 移除通知队列 等待被removal listener消费
   * */
  // TODO(fry): define a new type which creates event objects and automates the clear logic
  final Queue&lt;RemovalNotification&lt;K, V&gt;&gt; removalNotificationQueue;

  /**
   * A listener that is invoked when an entry is removed due to expiration or garbage collection of
   * soft/weak entries.
   *
   * 监听一个entry因为到期回收或被垃圾回收器回收而触发的动作
   */
  final RemovalListener&lt;K, V&gt; removalListener;

  /** Measures time in a testable way.
   * 时间工具
   * */
  final Ticker ticker;

  /** Factory used to create new entries. */
  final EntryFactory entryFactory;

  /**
   * Accumulates global cache statistics. Note that there are also per-segments stats counters which
   * must be aggregated to obtain a global stats view.
   *
   * 统计
   */
  final StatsCounter globalStatsCounter;

  /** The default cache loader to use on loading operations.
   * 缓存自动加载策略
   * */
  final @Nullable CacheLoader&lt;? super K, V&gt; defaultLoader;

  /**
   * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.
   */
  LocalCache(
      CacheBuilder&lt;? super K, ? super V&gt; builder, @Nullable CacheLoader&lt;? super K, V&gt; loader) {
    concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);

    keyStrength = builder.getKeyStrength();
    valueStrength = builder.getValueStrength();

    keyEquivalence = builder.getKeyEquivalence();
    valueEquivalence = builder.getValueEquivalence();

    maxWeight = builder.getMaximumWeight();
    weigher = builder.getWeigher();
    expireAfterAccessNanos = builder.getExpireAfterAccessNanos();
    expireAfterWriteNanos = builder.getExpireAfterWriteNanos();
    refreshNanos = builder.getRefreshNanos();

    removalListener = builder.getRemovalListener();
    removalNotificationQueue =
        (removalListener == NullListener.INSTANCE)
            ? LocalCache.&lt;RemovalNotification&lt;K, V&gt;&gt;discardingQueue()
            : new ConcurrentLinkedQueue&lt;RemovalNotification&lt;K, V&gt;&gt;();

    ticker = builder.getTicker(recordsTime());
    entryFactory = EntryFactory.getFactory(keyStrength, usesAccessEntries(), usesWriteEntries());
    globalStatsCounter = builder.getStatsCounterSupplier().get();
    defaultLoader = loader;

    int initialCapacity = Math.min(builder.getInitialCapacity(), MAXIMUM_CAPACITY);
    if (evictsBySize() &amp;&amp; !customWeigher()) {
      initialCapacity = (int) Math.min(initialCapacity, maxWeight);
    }

    // Find the lowest power-of-two segmentCount that exceeds concurrencyLevel, unless
    // maximumSize/Weight is specified in which case ensure that each segment gets at least 10
    // entries. The special casing for size-based eviction is only necessary because that eviction
    // happens per segment instead of globally, so too many segments compared to the maximum size
    // will result in random eviction behavior.
    int segmentShift = 0;
    int segmentCount = 1;
    while (segmentCount &lt; concurrencyLevel &amp;&amp; (!evictsBySize() || segmentCount * 20 &lt;= maxWeight)) {
      ++segmentShift;
      segmentCount &lt;&lt;= 1;
    }
    this.segmentShift = 32 - segmentShift;
    segmentMask = segmentCount - 1;

    this.segments = newSegmentArray(segmentCount);

    int segmentCapacity = initialCapacity / segmentCount;
    if (segmentCapacity * segmentCount &lt; initialCapacity) {
      ++segmentCapacity;
    }

    int segmentSize = 1;
    while (segmentSize &lt; segmentCapacity) {
      segmentSize &lt;&lt;= 1;
    }

    
    if (evictsBySize()) {//使用按大小回收策略
      // Ensure sum of segment max weights = overall max weights
      //计算每个segment平分下来的大小
      long maxSegmentWeight = maxWeight / segmentCount + 1;
      long remainder = maxWeight % segmentCount;
      for (int i = 0; i &lt; this.segments.length; ++i) {
        if (i == remainder) {
          maxSegmentWeight--;
        }
        this.segments[i] =
            createSegment(segmentSize, maxSegmentWeight, builder.getStatsCounterSupplier().get());
      }
    } else {
      for (int i = 0; i &lt; this.segments.length; ++i) {
        this.segments[i] =
            createSegment(segmentSize, UNSET_INT, builder.getStatsCounterSupplier().get());
      }
    }
  }
</code></pre>
<pre><code class="language-java">// Inner Classes

@SuppressWarnings("serial") // This class is never serialized.
static class Segment&lt;K, V&gt; extends ReentrantLock {

  @Weak final LocalCache&lt;K, V&gt; map;

  /** 
   * 当前segment中生效的元素的个数
   * */
  volatile int count;

  /** 
   * 当前segment中生效元素的大小的总和
   * */
  @GuardedBy("this")
  long totalWeight;

  /**
   * 修改次数
   */
  int modCount;

  /**
   * 扩容阀值 threshold = table.length * loadFactor（0.75）
   */
  int threshold;

  /** 
   * 当前segment中存放元素的表
   * */
  volatile @Nullable AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table;

  /** 
   允许segment最大大小
  */
  final long maxSegmentWeight;

  /**
   * 存放key已经被垃圾回收的entries的队列
   * 根据引用强度(强引用 软引用 虚引用)清除元素策略
   */
  final @Nullable ReferenceQueue&lt;K&gt; keyReferenceQueue;

  /**
   * 存放value已经被垃圾回收的entries的队列
   */
  final @Nullable ReferenceQueue&lt;V&gt; valueReferenceQueue;

  /**
   * recencyQueue 启用条件和accessQueue一样。
   * 每次访问操作都会将该entry加入到队列尾部，并更新accessTime。
   * 如果遇到写入操作，则将该队列内容排干，如果accessQueue队列中持有该这些 entry，然后将这些entry add到accessQueue队列。
   * 注意，因为accessQueue是非线程安全的，所以如果每次访问entry时就将该entry加入到accessQueue队列中，就会导致并发问题。
   * 所以这里每次访问先将entry临时加入到并发安全的ConcurrentLinkedQueue队列中，也就是recencyQueue中。
   * 在写入的时候通过加锁的方式，将recencyQueue中的数据添加到accessQueue队列中。
   * 如此看来，recencyQueue是为 accessQueue服务的
   */
  final Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; recencyQueue;

  /**
   * A counter of the number of reads since the last write, used to drain queues on a small
   * fraction of read operations.
   */
  final AtomicInteger readCount = new AtomicInteger();

  /**
   * 写队列
   */
  @GuardedBy("this")
  final Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; writeQueue;

  /**
   * 访问队列
   */
  @GuardedBy("this")
  final Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; accessQueue;

  /** Accumulates cache statistics. */
  final StatsCounter statsCounter;

  Segment(
      LocalCache&lt;K, V&gt; map,
      int initialCapacity,
      long maxSegmentWeight,
      StatsCounter statsCounter) {
    this.map = map;
    this.maxSegmentWeight = maxSegmentWeight;
    this.statsCounter = checkNotNull(statsCounter);
    initTable(newEntryArray(initialCapacity));

    keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue&lt;K&gt;() : null;

    valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue&lt;V&gt;() : null;

    recencyQueue =
        map.usesAccessQueue()
            ? new ConcurrentLinkedQueue&lt;ReferenceEntry&lt;K, V&gt;&gt;()
            : LocalCache.&lt;ReferenceEntry&lt;K, V&gt;&gt;discardingQueue();

    writeQueue =
        map.usesWriteQueue()
            ? new WriteQueue&lt;K, V&gt;()
            : LocalCache.&lt;ReferenceEntry&lt;K, V&gt;&gt;discardingQueue();

    accessQueue =
        map.usesAccessQueue()
            ? new AccessQueue&lt;K, V&gt;()
            : LocalCache.&lt;ReferenceEntry&lt;K, V&gt;&gt;discardingQueue();
  }

...
}



</code></pre>
</li>
<li>
<p>CacheLoader是一个抽象类，是用户自己实现的缓存加载策略，即负责在获取不到缓存的时候根据策略创建缓存返回。</p>
</li>
<li>
<p>CacheBuilder 由于cache配置项众多，典型的builder模式场景，复杂对象的构造与其对应配置属性表示的分离。</p>
<p>它提供三种方式加载到缓存中。分别是：</p>
<ol>
<li>在构建缓存的时候，使用build方法内部调用CacheLoader方法加载数据；</li>
<li>callable 、callback方式加载数据；</li>
<li>使用粗暴直接的方式，直接Cache.put 加载数据，但自动加载是首选的，因为它可以更容易的推断所有缓存内容的一致性。</li>
</ol>
<p>build生成器的两种方式都实现了一种逻辑：从缓存中取key的值，如果该值已经缓存过了则返回缓存中的值，如果没有缓存过可以通过某个方法来获取这个值，不同的地方在于cacheloader的定义比较宽泛，是针对整个cache定义的，可以认为是统一的根据key值load value的方法，而callable的方式较为灵活，允许你在get的时候指定load方法。</p>
</li>
</ul>
<p>Guava Cache数据结构图</p>
<p><img src="https://img2020.cnblogs.com/blog/1054413/202106/1054413-20210618172723510-107460484.png" alt="" loading="lazy"></p>
<p><strong>ReferenceEntry</strong>是对一个键值对节点的抽象，它包含了key和值的ValueReference抽象类，Cache由多个Segment组成，而每个Segment包含一个ReferenceEntry数组，每个ReferenceEntry数组项都是一条ReferenceEntry链，且一个ReferenceEntry包含key、hash、valueReference、next字段。除了在ReferenceEntry数组项中组成的链，在一个Segment中，所有ReferenceEntry还组成access链（accessQueue）和write链（writeQueue）（后面会介绍链的作用）。ReferenceEntry可以是强引用类型的key，也可以WeakReference类型的key，为了减少内存使用量，还可以根据是否配置了expireAfterWrite、expireAfterAccess、maximumSize来决定是否需要write链和access链确定要创建的具体Reference：StrongEntry、StrongWriteEntry、StrongAccessEntry、StrongWriteAccessEntry等。</p>
<p><strong>对于ValueReference</strong>，因为Cache支持强引用的Value、SoftReference Value以及WeakReference Value，因而它对应三个实现类：StrongValueReference、SoftValueReference、WeakValueReference。为了支持动态加载机制，它还有一个LoadingValueReference，在需要动态加载一个key的值时，先把该值封装在LoadingValueReference中，以表达该key对应的值已经在加载了，如果其他线程也要查询该key对应的值，就能得到该引用，并且等待改值加载完成，从而保证该值只被加载一次，在该值加载完成后，将LoadingValueReference替换成其他ValueReference类型。ValueReference对象中会保留对ReferenceEntry的引用，这是因为在Value因为WeakReference、SoftReference被回收时，需要使用其key将对应的项从Segment的table中移除。</p>
<p><strong>WriteQueue和AccessQueue ：</strong>为了实现最近最少使用算法，Guava Cache在Segment中添加了两条链：write链（writeQueue）和access链（accessQueue），这两条链都是一个双向链表，通过ReferenceEntry中的previousInWriteQueue、nextInWriteQueue和previousInAccessQueue、nextInAccessQueue链接而成，但是以Queue的形式表达。WriteQueue和AccessQueue都是自定义了offer、add（直接调用offer）、remove、poll等操作的逻辑，对offer（add）操作，如果是新加的节点，则直接加入到该链的结尾，如果是已存在的节点，则将该节点链接的链尾；对remove操作，直接从该链中移除该节点；对poll操作，将头节点的下一个节点移除，并返回。</p>
<p><strong>了解了cache的整体数据结构后，再来看下针对缓存的相关操作就简单多了：</strong></p>
<ul>
<li>Segment中的evict清除策略操作，是在每一次调用操作的开始和结束时触发清理工作，这样比一般的缓存另起线程监控清理相比，可以减少开销，但如果长时间没有调用方法的话，会导致不能及时的清理释放内存空间的问题。evict主要处理四个Queue：1. keyReferenceQueue；2. valueReferenceQueue；3. writeQueue；4. accessQueue。前两个queue是因为WeakReference、SoftReference被垃圾回收时加入的，清理时只需要遍历整个queue，将对应的项从LocalCache中移除即可，这里keyReferenceQueue存放ReferenceEntry，而valueReferenceQueue存放的是ValueReference，要从Cache中移除需要有key，因而ValueReference需要有对ReferenceEntry的引用，这个前面也提到过了。而对后面两个Queue，只需要检查是否配置了相应的expire时间，然后从头开始查找已经expire的Entry，将它们移除即可。</li>
<li>Segment中的put操作：put操作相对比较简单，首先它需要获得锁，然后尝试做一些清理工作，接下来的逻辑类似ConcurrentHashMap中的rehash，查找位置并注入数据。需要说明的是当找到一个已存在的Entry时，需要先判断当前的ValueRefernece中的值事实上已经被回收了，因为它们可以是WeakReference、SoftReference类型，如果已经被回收了，则将新值写入。并且在每次更新时注册当前操作引起的移除事件，指定相应的原因：COLLECTED、REPLACED等，这些注册的事件在退出的时候统一调用Cache注册的RemovalListener，由于事件处理可能会有很长时间，因而这里将事件处理的逻辑在退出锁以后才做。最后，在更新已存在的Entry结束后都尝试着将那些已经expire的Entry移除。另外put操作中还需要更新writeQueue和accessQueue的语义正确性。</li>
<li>Segment带CacheLoader的get操作：1. 先查找table中是否已存在没有被回收、也没有expire的entry，如果找到，并在CacheBuilder中配置了refreshAfterWrite，并且当前时间间隔已经超过这个时间，则重新加载值，否则，直接返回原有的值；2. 如果查找到的ValueReference是LoadingValueReference，则等待该LoadingValueReference加载结束，并返回加载的值；3. 如果没有找到entry，或者找到的entry的值为null，则加锁后，继续在table中查找已存在key对应的entry，如果找到并且对应的entry.isLoading()为true，则表示有另一个线程正在加载，因而等待那个线程加载完成，如果找到一个非null值，返回该值，否则创建一个LoadingValueReference，并调用loadSync加载相应的值，在加载完成后，将新加载的值更新到table中，即大部分情况下替换原来的LoadingValueReference。</li>
</ul>
<p>测试构建实现不同回收策略的LoadingCache的实例，分析put和get的实现的细节。</p>
<ul>
<li>put操作过程解析：</li>
</ul>
<p>1.测试入口：构建一个实现支持缓存最大个数缓存策略且有自动加载特性的本地缓存LoadingCache。</p>
<pre><code class="language-java">    public static void main(String[] args) throws Exception{
        debugMaximumSize();
//        debugExpireAfterWrite();
//        debugExpireAfterAccess();
    }

    private static void debugMaximumSize() throws Exception{
                LoadingCache&lt;String, String&gt; loadingCache = CacheBuilder.newBuilder()
                .maximumSize(4)
                .build(
                        new CacheLoader&lt;String, String&gt;() {
                            @Override
                            public String load(String key) throws Exception {
                                System.out.println("key:" + key + " is not exist. do nothing.");
                                return "111";
                            }
                        });
        loadingCache.put("zhangtianci","good");
				loadingCache.get("zhangtianci");
    }
</code></pre>
<p>2.进入到实现标准接口Cache的LocalManualCache的put的方法，实际通过拥有一个LocalCache的成员变量调用其put方法。</p>
<pre><code class="language-java">static class LocalManualCache&lt;K, V&gt; implements Cache&lt;K, V&gt;, Serializable {
  //拥有一个LocalCache的成员变量
 final LocalCache&lt;K, V&gt; localCache;
  
@Override
public void put(K key, V value) {
  localCache.put(key, value);
}
}
</code></pre>
<p>3.进入到LocalCache的put方法，对key进行hash定位到segment[]的下标，调用具体对应segment实例的put方法。</p>
<pre><code class="language-java">class LocalCache{
@Override
public V put(K key, V value) {
  checkNotNull(key);
  checkNotNull(value);
  int hash = hash(key);
  return segmentFor(hash).put(key, hash, value, false);
}
  ..
}
</code></pre>
<pre><code>* Callable
  */
  public void callablex() throws ExecutionException
    {
  Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()
    .maximumSize(1000).build();
  String result = cache.get("key", new Callable&lt;String&gt;()
   {
     public String call()
     {
      return "result";
     }
   });
      System.out.println(result);
    }
</code></pre>
<p>4.进入到segment的put方法</p>
<p>​	1.上锁，写前清理操作，回收被垃圾回收的entries和过期的entries</p>
<p>​	2.判断segment是否需要扩容</p>
<p>​	3.确定写入元素在table中的下标并拿到该下标的头元素，遍历该链表找到这个entry，覆盖或不做处理或新增。</p>
<p>​	4.解锁，写后清理操作，将removalNotificationQueue队列里面注册的移除事件，一一触发相应的动作。</p>
<pre><code class="language-java">@Nullable
V put(K key, int hash, V value, boolean onlyIfAbsent) {
  lock();
  try {
    long now = map.ticker.read();
    //写操作前
    // 1.驱逐参考队列
    // 2.驱逐过期entries
    preWriteCleanup(now);
    //判断segment是否需要扩容
    int newCount = this.count + 1;
    if (newCount &gt; this.threshold) { // ensure capacity
      expand();
      newCount = this.count + 1;
    }
    //确定写入元素在table中的下标并拿到该下标的头元素
    AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = this.table;
    int index = hash &amp; (table.length() - 1);
    ReferenceEntry&lt;K, V&gt; first = table.get(index);

    // Look for an existing entry.
    //遍历该链表 找到这个entry
    for (ReferenceEntry&lt;K, V&gt; e = first; e != null; e = e.getNext()) {
      K entryKey = e.getKey();
      if (e.getHash() == hash
          &amp;&amp; entryKey != null
          &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) {
        // We found an existing entry.
        //找到该entry

        ValueReference&lt;K, V&gt; valueReference = e.getValueReference();
        V entryValue = valueReference.get();

        if (entryValue == null) {//entryValue被垃圾回收了
          ++modCount;
          if (valueReference.isActive()) {
            enqueueNotification(
                key, hash, entryValue, valueReference.getWeight(), RemovalCause.COLLECTED);
            setValue(e, key, value, now);
            newCount = this.count; // count remains unchanged
          } else {
            setValue(e, key, value, now);
            newCount = this.count + 1;
          }
          this.count = newCount; // write-volatile
          evictEntries(e);
          return null;
        } else if (onlyIfAbsent) {
          // Mimic
          // "if (!map.containsKey(key)) ...
          // else return map.get(key);
          //仅更新access queue队列的顺序
          recordLockedRead(e, now);
          return entryValue;
        } else {
          // clobber existing entry, count remains unchanged
          //覆盖现有条目，计数保持不变
          ++modCount;
          enqueueNotification(
              key, hash, entryValue, valueReference.getWeight(), RemovalCause.REPLACED);
          setValue(e, key, value, now);
          evictEntries(e);
          return entryValue;
        }
      }
    }

    // Create a new entry.
    //没有找到entry 创建一个新的entry
    ++modCount;
    ReferenceEntry&lt;K, V&gt; newEntry = newEntry(key, hash, first);
    setValue(newEntry, key, value, now);
    table.set(index, newEntry);
    newCount = this.count + 1;
    this.count = newCount; // write-volatile
    evictEntries(newEntry);
    return null;
  } finally {
    unlock();
    //并且在每次更新时注册当前操作引起的移除事件，指定相应的原因：COLLECTED、REPLACED等，
    // 这些注册的事件在退出的时候统一调用Cache注册的RemovalListener，
    // 由于事件处理可能会有很长时间，因而这里将事件处理的逻辑在退出锁以后才做。
    postWriteCleanup();
  }
}
</code></pre>
<p>看看写前清理操作的实现细节：</p>
<p>加锁，驱逐参考队列和驱逐过期entries</p>
<pre><code class="language-java">@GuardedBy("this")
void preWriteCleanup(long now) {
  runLockedCleanup(now);
}
</code></pre>
<pre><code class="language-java">void runLockedCleanup(long now) {
  if (tryLock()) {
    try {
      //驱逐参考队列
      drainReferenceQueues();
      //驱逐过期entries
      expireEntries(now); // calls drainRecencyQueue
      readCount.set(0);
    } finally {
      unlock();
    }
  }
}
</code></pre>
<p>驱逐参考队列实现细节</p>
<pre><code class="language-java">/**
 * 驱逐参考队列
 */
@GuardedBy("this")
void drainReferenceQueues() {
  if (map.usesKeyReferences()) {
    drainKeyReferenceQueue();
  }
  if (map.usesValueReferences()) {
    drainValueReferenceQueue();
  }
}
</code></pre>
<pre><code class="language-java">@GuardedBy("this")
void drainKeyReferenceQueue() {
  Reference&lt;? extends K&gt; ref;
  int i = 0;
  while ((ref = keyReferenceQueue.poll()) != null) {
    @SuppressWarnings("unchecked")
    ReferenceEntry&lt;K, V&gt; entry = (ReferenceEntry&lt;K, V&gt;) ref;
    map.reclaimKey(entry);
    if (++i == DRAIN_MAX) {   //此次操作最多清除16个
      break;
    }
  }
}
</code></pre>
<pre><code class="language-java">@GuardedBy("this")
void drainValueReferenceQueue() {
  Reference&lt;? extends V&gt; ref;
  int i = 0;
  while ((ref = valueReferenceQueue.poll()) != null) {
    @SuppressWarnings("unchecked")
    ValueReference&lt;K, V&gt; valueReference = (ValueReference&lt;K, V&gt;) ref;
    map.reclaimValue(valueReference);
    if (++i == DRAIN_MAX) {
      break;
    }
  }
}
</code></pre>
<p>驱逐过期entries实现细节</p>
<pre><code class="language-java">/**
 * 驱逐过期entries
 * @param now
 */
@GuardedBy("this")
void expireEntries(long now) {
  //清空最近使用队列
  //recencyQueue 是在访问时维护的一个并发安全的最近使用队列
  drainRecencyQueue();

  //清空writeQueue所有过期的entry
  ReferenceEntry&lt;K, V&gt; e;
  while ((e = writeQueue.peek()) != null &amp;&amp; map.isExpired(e, now)) {
    if (!removeEntry(e, e.getHash(), RemovalCause.EXPIRED)) {
      throw new AssertionError();
    }
  }
  //清空accessQueue所有过期的entry
  while ((e = accessQueue.peek()) != null &amp;&amp; map.isExpired(e, now)) {
    if (!removeEntry(e, e.getHash(), RemovalCause.EXPIRED)) {
      throw new AssertionError();
    }
  }
}
</code></pre>
<pre><code class="language-java">/**
 * 排干最近使用队列，将队列放到accessQueue中
 */
@GuardedBy("this")
void drainRecencyQueue() {
  ReferenceEntry&lt;K, V&gt; e;
  while ((e = recencyQueue.poll()) != null) {
    if (accessQueue.contains(e)) {
      accessQueue.add(e);
    }
  }
}
</code></pre>
<p>移除entry实现细节:</p>
<pre><code class="language-java">@VisibleForTesting
@GuardedBy("this")
boolean removeEntry(ReferenceEntry&lt;K, V&gt; entry, int hash, RemovalCause cause) {
  //获取entry当前segement中所属链表的头元素
  int newCount = this.count - 1;
  AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = this.table;
  int index = hash &amp; (table.length() - 1);
  ReferenceEntry&lt;K, V&gt; first = table.get(index);

  //遍历链表
  for (ReferenceEntry&lt;K, V&gt; e = first; e != null; e = e.getNext()) {
    if (e == entry) {
      ++modCount;
      ReferenceEntry&lt;K, V&gt; newFirst =
          removeValueFromChain(
              first,
              e,
              e.getKey(),
              hash,
              e.getValueReference().get(),
              e.getValueReference(),
              cause);
      newCount = this.count - 1;
      table.set(index, newFirst);
      this.count = newCount; // write-volatile
      return true;
    }
  }

  return false;
}
</code></pre>
<pre><code class="language-java">@GuardedBy("this")
@Nullable
ReferenceEntry&lt;K, V&gt; removeValueFromChain(
    ReferenceEntry&lt;K, V&gt; first,
    ReferenceEntry&lt;K, V&gt; entry,
    @Nullable K key,
    int hash,
    V value,
    ValueReference&lt;K, V&gt; valueReference,
    RemovalCause cause) {
  enqueueNotification(key, hash, value, valueReference.getWeight(), cause);
  writeQueue.remove(entry);	//维护writeQueue
  accessQueue.remove(entry);	//维护accessQueue

  if (valueReference.isLoading()) {
    valueReference.notifyNewValue(null);
    return first;
  } else {
    return removeEntryFromChain(first, entry);//从实际存放数据的table中移除该entry
  }
}
</code></pre>
<p>put操作替换value实现细节：</p>
<pre><code class="language-java">@GuardedBy("this")
void setValue(ReferenceEntry&lt;K, V&gt; entry, K key, V value, long now) {
  ValueReference&lt;K, V&gt; previous = entry.getValueReference();
  int weight = map.weigher.weigh(key, value);
  checkState(weight &gt;= 0, "Weights must be non-negative");

  ValueReference&lt;K, V&gt; valueReference =
      map.valueStrength.referenceValue(this, entry, value, weight);//根据回收策略（value的强/弱/软引用）new 一个ValueReference
  entry.setValueReference(valueReference);
  recordWrite(entry, weight, now);//记录写，是否需要记录访问时间和写时间，并往加入到accessQueue和writeQueue
  previous.notifyNewValue(value);
}
</code></pre>
<pre><code class="language-java"> /**
	记录写操作，是否需要记录访问时间和写时间，并往加入到accessQueue和writeQueue
	*/
void recordWrite(ReferenceEntry&lt;K, V&gt; entry, int weight, long now) {
  // we are already under lock, so drain the recency queue immediately
  drainRecencyQueue();
  totalWeight += weight;

  if (map.recordsAccess()) {
    entry.setAccessTime(now);
  }
  if (map.recordsWrite()) {
    entry.setWriteTime(now);
  }
  accessQueue.add(entry);
  writeQueue.add(entry);
}
</code></pre>
<p>写后清理操作实现细节:</p>
<pre><code class="language-java">void postWriteCleanup() {
  runUnlockedCleanup();
}
</code></pre>
<pre><code class="language-java">void runUnlockedCleanup() {
    // locked cleanup may generate notifications we can send unlocked
    if (!isHeldByCurrentThread()) {
      map.processPendingNotifications();
    }
  }
}
</code></pre>
<pre><code class="language-java">void processPendingNotifications() {
  RemovalNotification&lt;K, V&gt; notification;
  while ((notification = removalNotificationQueue.poll()) != null) {
    try {
      removalListener.onRemoval(notification);
    } catch (Throwable e) {
      logger.log(Level.WARNING, "Exception thrown by removal listener", e);
    }
  }
}
</code></pre>
<ul>
<li>get操作过程解析：</li>
</ul>
<p>进入到实现LoadingCache接口的有自动加载特性的LocalLoadingCache的get方法</p>
<pre><code class="language-java">static class LocalLoadingCache&lt;K, V&gt; extends LocalManualCache&lt;K, V&gt;
    implements LoadingCache&lt;K, V&gt; {

  LocalLoadingCache(
      CacheBuilder&lt;? super K, ? super V&gt; builder, CacheLoader&lt;? super K, V&gt; loader) {
    super(new LocalCache&lt;K, V&gt;(builder, checkNotNull(loader)));
  }

  // LoadingCache methods

  @Override
  public V get(K key) throws ExecutionException {
    return localCache.getOrLoad(key);
  }
</code></pre>
<p>其实是调用成员变量localCache的getOrLoad(key)方法,对key进行hash，定位到segment[]下标，调用segment的get方法</p>
<pre><code class="language-java">V get(K key, CacheLoader&lt;? super K, V&gt; loader) throws ExecutionException {
  int hash = hash(checkNotNull(key));
  return segmentFor(hash).get(key, hash, loader);
}
</code></pre>
<pre><code class="language-java">V get(K key, int hash, CacheLoader&lt;? super K, V&gt; loader) throws ExecutionException {
  checkNotNull(key);
  checkNotNull(loader);
  try {
    if (count != 0) { // read-volatile
      // don't call getLiveEntry, which would ignore loading values
      //获取该entry
      ReferenceEntry&lt;K, V&gt; e = getEntry(key, hash);
      if (e != null) {
        long now = map.ticker.read();
        V value = getLiveValue(e, now);//判断entry的value是否有效
        if (value != null) {
          recordRead(e, now);
          statsCounter.recordHits(1);
          return scheduleRefresh(e, key, hash, value, now, loader);
        }
        ValueReference&lt;K, V&gt; valueReference = e.getValueReference();
        if (valueReference.isLoading()) {//是否正在加载
          return waitForLoadingValue(e, key, valueReference);
        }
      }
    }

    // at this point e is either null or expired;
    //创建 缓存 返回
    return lockedGetOrLoad(key, hash, loader);
  } catch (ExecutionException ee) {
    Throwable cause = ee.getCause();
    if (cause instanceof Error) {
      throw new ExecutionError((Error) cause);
    } else if (cause instanceof RuntimeException) {
      throw new UncheckedExecutionException(cause);
    }
    throw ee;
  } finally {
    postReadCleanup();//读后清理操作
  }
}
</code></pre>
<p>未完待续...</p>
<blockquote>
<p><strong>总体来看，Guava Cache基于ConcurrentHashMap的优秀设计借鉴，在高并发场景支持和线程安全上都有相应的改进策略，使用Reference引用命令，提升高并发下的数据……访问速度并保持了GC的可回收，有效节省空间；同时，write链和access链的设计，能更灵活、高效的实现多种类型的缓存清理策略，包括基于容量的清理、基于时间的清理、基于引用的清理等；编程式的build生成器管理，让使用者有更多的自由度，能够根据不同场景设置合适的模式。</strong></p>
</blockquote>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2021-06-18 17:29</span>&nbsp;
<a href="https://www.cnblogs.com/tc971121/">张天赐的博客</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=14900517" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(14900517);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '14900517', targetLink: 'https://www.cnblogs.com/tc971121/p/14900517.html', title: 'guavacache源码阅读笔记' })">举报</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/10.3.1/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 322910, cb_blogApp = 'tc971121', cb_blogUserGuid = 'c85fc5ed-629f-e611-845c-ac853d9f53ac';
    var cb_entryId = 14900517, cb_entryCreatedDate = '2021-06-18 17:29', cb_postType = 1;
    updatePostStats(
        [cb_entryId],
        function(id, count) { $("#post_view_count").text(count) },
        function(id, count) { $("#post_comment_count").text(count) })
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
</script>
<a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
    <div id="cnblogs_c2" class="under-post-card">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
       var commentManager = new blogCommentManager();
       commentManager.renderComments(0);
       fixPostBody();
       deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);       deliverT2();
       deliverC1C2();
       loadNewsAndKb();
       loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);       LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
       GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
       loadOptUnderPost();
       GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2021 张天赐的博客
<br /><span id="poweredby">Powered by .NET 5.0 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    

    <input type="hidden" id="antiforgery_token" value="CfDJ8L-rpLgFVEJMgssCVvNUAjs1SJ_SSOjXANdy5czg4CyxnlNWkWe4uURi9bbKtAgTWpGC2ZijjENKwMOFeRbT3JvxN52UwpVNaTat2THhHFjj-sI9-4PpEb3Q_3M3AcY3sBcikbjeE4nMN6YQ11GVxl4" />
</body>
</html>
